---
layout: post
title: 'java tuple（元组）'
subtitle: ''
date: 2017-05-30
categories: 技术
cover: ''
tags: java 编程语言
---

# java tuple（元组）

> 很经常我们希望方法的return能够返回多个对象，可是遗憾的是java只能有一个返回值（类型），为了实现这个功能我们可能会去编写一个特别的类，让它能够携带多的返回值，这样的概念称之为 **元组（Tuple）** 也称为 **数据传输对象、信使**。

为了实现这个元组，我们编写了如下的代码。
```
public class DataSet{
    private String string1;
    private String string2;

    public String getString1() {
        return string1;
    }

    public void setString1(String string1) {
        this.string1 = string1;
    }

    public String getString2() {
        return string2;
    }

    public void setString2(String string2) {
        this.string2 = string2;
    }
}
```
OK，上面的 *DataSet* 确实解决了我们的当务之急，但是总感觉很不合理，确实。如果我们要的不仅仅是String 类型的多个返回值的？
很好，你想到了泛型，没错。就是用泛型去解决这种问题。

```
public class TupleTwo<A,B>{
    private A a;
    private B b;

    public A getA() {
        return a;
    }

    public void setA(A a) {
        this.a = a;
    }

    public B getB() {
        return b;
    }

    public void setB(B b) {
        this.b = b;
    }
}
```
如上，*TupleTwo* 这是个通常的javaBean，很好的处理属性类型的多态性，但我们有更好的编写方式：

```
public class TupleTwo<A,B>{
    public final A a;
    public final B b;

    public TupleTwo(A a, B b) {
        this.a = a;
        this.b = b;
    }
}
```

我们将a和b声明为final且是公开的属性，这样它就只能被一次赋值而不能被再次修改，而恰好，return语句也就仅仅是携带数据返回而已，不需要对携带体有更多的修改。

为了能兼容更多的数据，我们可以通过继承来实现这样的操作，当你想携带几个就使用特定的tuple。

```

class Tuple3<A, B, C> extends Tuple2<A, B> {
    public final C c;

    public Tuple3(A a, B b, C c) {
        super(a, b);
        this.c = c;
    }
}

class Tuple4<A, B, C, D> extends Tuple3<A, B, C> {
    public final D d;

    public Tuple4(A a, B b, C c, D d) {
        super(a, b, c);
        this.d = d;
    }
}

```
然后通过一个工具类来调用它们

```
public class Tuple {
    public static <A, B> Tuple2 tuple(A a, B b) {
        return new Tuple2<>(a, b);
    }

    public static <A, B, C> Tuple3 tuple(A a, B b, C c) {
        return new Tuple3<>(a, b, c);
    }

    public static <A, B, C, D> Tuple4 tuple(A a, B b, C c, D d) {
        return new Tuple4<>(a, b, c, d);
    }
}
```
